# 8.2 关键字：const

## const对象必须初始化

因为const对象一旦创建后其值就不能再改变，因此const对象必须初始化，其初始值可以是任意复杂的表达式：

```c++
const int i = get_size();  // 正确: 运行时初始化
const int j = 42;          // 正确: 编译时初始化
const int k;               // 错误: 未经初始化的const变量
```

## const对象仅在文件内有效

举个例子，我们在编译时初始化一个const对象：

```c++
const int i = 10;
```

编译器会在编译过程把用到该变量的地方都替换为对应的值。为了执行这个替换，编译器必须知道变量的初始值，如果程序包含多个文件，那么每个用了这个const对象的文件都必须得能访问到它的初始值才行（即每个文件都要定义const对象）。为了避免对同一变量的重复定义，当多个文件中出现同名的const对象时，其实等同于在不同文件中分别定义了独立的变量。

```c++
/*
 * 下面是合法的, 不存在变量i重复定义问题
 */

// foo.cpp
const int i = 10;

// bar.cpp
const int i = 5;
```

如果想在多个文件之间共享const对象，那么必须在变量的定义之前添加extern关键字：

```c++
/*
 * 下面是合法的, main.cpp和foo.cpp中的const int对象是同一个
 */

// foo.cpp
extern const int i = 10;

// main.cpp
#include <iostream>

int main(void) {
    extern int i;
    std::cout << "i:" << i << std::endl;
}
```

## 允许常量引用绑定非常量对象、字面值甚至一般表达式

一般而言，引用的类型必须与其所引用对象的类型一致，但是有两个例外：

* 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用类型即可，允许为一个常量引用绑定非常量的对象、字面值甚至是一个一般表达式（如下）
* 可以将基类的指针或引用绑定到派生类对象上（后续面向对象章节再探讨）

```c++
int i = 10;

const int &ri1 = i;      // 合法: 绑定到非常量对象
const int &ri2 = 100;    // 合法: 绑定到字面值
const int &ri3 = 1 + 1;  // 合法: 绑定到一般表达式
```

## 顶层const与底层const

指针本身是一个对象，因此指针本身是不是常量与指针所指对象是不是常量是两个独立的问题，前者被称为顶层const，后者被称为底层const。

> Tips：指针类型既可以是顶层const也可以是底层const，其他类型要么是顶层常量要么是底层常量。

顶层const用于表示任意的对象是常量，包括算数类型、类和指针等，底层const用于表示引用和指针等复合类型的基本类型部分是否是常量。

```c++
int i = 10;

int *const p1 = &i;        // 顶层const: 不能改变p1的值
const int *p2 = &i;        // 底层const: 不能通过p2改变i的值
const int *const p3 = &i;  // 底层const + 顶层const

const int &r1 = i;         // 底层const: 不能通过r1改变i的值
```