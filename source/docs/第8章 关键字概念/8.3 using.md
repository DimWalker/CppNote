# 8.3 关键字：using

## using定义类型别名

C++11新标准引入了using关键字来定义类型别名（传统方法是用typedef定义类型别名）：

```c++
using Dict = std::map<std::string, std::string>;
Dict dict;  // dict的类型是map<string, string> 
```

## 命名空间的using声明

#### 1. using声明命名空间内的成员

使用命名空间的using声明后，我们使用命名空间内的成员时就无须加上命名空间的前缀了，例如：

```c++
#include <iostream>

int main(void) {
    using std::cout;
    using std::endl;

    cout << "tomocat" << endl;
}

// 输出:
tomocat
```

#### 2. using声明整个命名空间（不推荐）

当然，我们也可以用using直接声明整个命名空间，这样使用命名空间内的所有成员都无须加上前缀了，例如：

> Tips：不推荐用using声明整个命名空间, 这样会引入该命名空间内的所有成员，如果有和用户代码重名的成员可能引发非预期的错误。

```c++
#include <iostream>

int main(void) {
    using namespace std;  // 不推荐的写法

    cout << "tomocat" << endl;
}
```

#### 3. 头文件不要包含命名空间的using声明

在头文件中包含了命名空间的using声明会导致所有引入该头文件的文件都包含这个声明，可能会产生非预期的命名冲突。

## 派生类改变个别成员的可访问性

有时我们需要改变派生类继承的某个名字的访问级别，通过使用`using`声明可以实现这一目的：

```c++
class Base {
 public:
    std::size_t size() const { return n; }
 protected:
    std::size_t n;
};

// private继承: 继承而来的成员是私有成员
class SubClass : private Base {
 public:
    using Base::size;
 protected:
    using Base::n;
};
```

因为SubClass使用了私有继承，所以继承而来的成员`size`和`n`默认是派生类`SubClass`的私有成员，然而我们使用`using`声明语句改变了这些成员的可访问性。改变之后`SubClass`的用户将可以使用`size`成员，而`SubClass`的派生类可以使用`n`。

> Tips：派生类只能为那些它可以访问（非私有成员）的名字提供`using`声明。

## 类模板的类型别名

C++11新标准允许我们为类模板定义一个类型别名：

```c++
// authors的类型是pair<string, string>
template<typename T> using twin = pair<T, T>;
twin<string> authors;
```

当我们定义一个模板类型别名时，也可以固定一个或多个模板参数：

```c++
template <typename T> using partNo = pair<T, unsigned>;
partNo<string> books;  // books类型是pair<string, unsigned>
partNo<Student> kids;  // kids类型是pair<Student, unsigned>
```

